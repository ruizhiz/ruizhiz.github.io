<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>验证经验总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="框架搭建在base_test中应该放什么？ RALs, 指向各个reg model的指针 各种seqr, adapter, predictors 的实例化 加上各种env. 做uvm_config_db#()::set。 base test应该尽可能得包含所有需要的东西。  base_vsequencer 中应该放什么？ 各个seqr.  cfg config等，  base_vseq 中应该放什">
<meta property="og:type" content="article">
<meta property="og:title" content="验证经验总结">
<meta property="og:url" content="http://example.com/2022/04/27/%E9%AA%8C%E8%AF%81%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="框架搭建在base_test中应该放什么？ RALs, 指向各个reg model的指针 各种seqr, adapter, predictors 的实例化 加上各种env. 做uvm_config_db#()::set。 base test应该尽可能得包含所有需要的东西。  base_vsequencer 中应该放什么？ 各个seqr.  cfg config等，  base_vseq 中应该放什">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-28T04:45:48.000Z">
<meta property="article:modified_time" content="2022-08-24T15:43:12.551Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-验证经验总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/27/%E9%AA%8C%E8%AF%81%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T04:45:48.000Z" itemprop="datePublished">2022-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      验证经验总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><h4 id="在base-test中应该放什么？"><a href="#在base-test中应该放什么？" class="headerlink" title="在base_test中应该放什么？"></a>在base_test中应该放什么？</h4><ol>
<li>RALs, 指向各个reg model的指针</li>
<li>各种seqr, adapter, predictors 的实例化</li>
<li>加上各种env.</li>
<li>做uvm_config_db#()::set。</li>
<li>base test应该尽可能得包含所有需要的东西。</li>
</ol>
<h4 id="base-vsequencer-中应该放什么？"><a href="#base-vsequencer-中应该放什么？" class="headerlink" title="base_vsequencer 中应该放什么？"></a>base_vsequencer 中应该放什么？</h4><ol>
<li>各个seqr. </li>
<li>cfg config等，</li>
</ol>
<h4 id="base-vseq-中应该放什么？"><a href="#base-vseq-中应该放什么？" class="headerlink" title="base_vseq 中应该放什么？"></a>base_vseq 中应该放什么？</h4><ol>
<li>创建各个ral_model的指针，然后通过config_db 指向对应的实例。这样，在各个child seq中如果想read&#x2F;write reg的话，直接使用就可以。</li>
<li>然后可以在里面放一些通用的task&#x2F;function, 这样就不用再在子seq中重复写了。</li>
</ol>
<h4 id="agent-注意事项"><a href="#agent-注意事项" class="headerlink" title="agent 注意事项"></a>agent 注意事项</h4><ol>
<li>agent 应该是per bus&#x2F;interface 的。</li>
</ol>
<h4 id="subsystem-TB"><a href="#subsystem-TB" class="headerlink" title="subsystem TB"></a>subsystem TB</h4><p>一个subsystem TB 中，可能包含上面已经验证过得module,或者IP. 这种情况下， 我们不应该再花费力气去验证子模块，而只需要做以下几个事项: </p>
<ol>
<li>确保这些block连接正确。</li>
<li>确保block之间的交流符合预期。</li>
<li>去验证那些还没有被验证过得block.</li>
</ol>
<h4 id="sequencer"><a href="#sequencer" class="headerlink" title="sequencer"></a>sequencer</h4><p> 多个seq经常在同一seqr上同时launch, seqr将会决定先发送哪一个。 </p>
<h4 id="sequence-item-amp-sequence-应该是什么样子的？"><a href="#sequence-item-amp-sequence-应该是什么样子的？" class="headerlink" title="sequence_item &amp; sequence 应该是什么样子的？"></a>sequence_item &amp; sequence 应该是什么样子的？</h4><ol>
<li><p>sequence item 会被送给driver， 并且告诉driver接下来要发送什么。但是他们一般不知道具体的protocol，也不会做决定。seq item 只是一个随机化的object,<br>对应于一个作用于interface上的event。 </p>
</li>
<li><p>sequence item应该是不可再细分的最小单元。如果不是这样的话，sequence item 可能需要经常修改，而，对应的driver, seqr, 等都要修改。麻烦。</p>
</li>
<li><p>如果要连续发一段的seq_item, 在seq中并不需要人为地加delay，如下图。这样直接发给driver, driver可以通过get_next_item()一个一个读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtual task body();</span><br><span class="line">    for(int i = int&#x27;(num) - 1; i &gt;= 0; i--)</span><br><span class="line">        `uvm_do_with(req, &#123; message == data[i]; &#125;)</span><br><span class="line">endtask : body</span><br></pre></td></tr></table></figure></li>
<li><p>seq &amp; vseq中应该包含几个要用到的变量，和rand 变量 &amp; 对应的constraints, 以及new(), body()。其他可选。</p>
</li>
<li><p>seq_item 中，应当包含几个要用到的变量，和 rand 变量 &amp; 对应的constraints,和new()。其他可选。 </p>
</li>
<li><p>在更高级的vseq&#x2F;test中，调用上述seq&#x2F;seq_item时，记得randomize them. </p>
</li>
<li><p>start()转化成的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_seq.randomize(...); // optional</span><br><span class="line">sub_seq.start(seqr, parent_seq, priority, call_pre_post)</span><br></pre></td></tr></table></figure>
<p>The following methods are called, in order</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub_seq.pre_start() (task)</span><br><span class="line">sub_seq.pre_body() (task) if call_pre_post==1</span><br><span class="line">parent_seq.pre_do(0) (task) if parent_sequence!=null</span><br><span class="line">parent_seq.mid_do(this) (func) if parent_sequence!=null</span><br><span class="line">sub_seq.body (task) YOUR STIMULUS CODE</span><br><span class="line">parent_seq.post_do(this) (func) if parent_sequence!=null</span><br><span class="line">sub_seq.post_body() (task) if call_pre_post==1</span><br><span class="line">sub_seq.post_start() (task)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="background-traffic"><a href="#background-traffic" class="headerlink" title="background traffic"></a>background traffic</h4><p>background traffic 是一些有时或者经常发生的数据流，但又不是test的主要测试的东西&#x2F;目的。其毫无疑问是非常重要的。 background traffic是可以随机产生，并且各个background seq<br>之间间隔也应该是随机并可调控的。当主seq结束以后，background traffic seq也应该跟着结束。</p>
<h4 id="randomize-中应当注意的事项"><a href="#randomize-中应当注意的事项" class="headerlink" title="randomize 中应当注意的事项"></a>randomize 中应当注意的事项</h4><ol>
<li><p>typedef enum logic [1:0] { V1_A &#x3D; 2’b00, V1_B &#x3D; 2’b01 } v1_e;<br>如果我们想rand 一个v1_e类型的值，那么v1_e的值只有可能是’b00,or ‘b01.而不可能是其他invalid 值。</p>
</li>
<li><pre><code>       std::randomize(val) with &#123; val dist &#123; 3 := 25,
    4 := 75&#125;;&#125;;
</code></pre>
<p>如果想在seq中，对某个变量 (val) 进行rand 并 constraint,可以使用上面这种方法，简单，方便. </p>
</li>
<li><p>class 是否声明为rand有何区别： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A_c;</span><br><span class="line">   rand int c_i;</span><br><span class="line">   rand bit z_b;</span><br><span class="line">endclass</span><br><span class="line">class B_c;</span><br><span class="line">   rand A_c A;</span><br><span class="line">   A= new();</span><br><span class="line">...</span><br><span class="line">endclass</span><br><span class="line">class C_c;</span><br><span class="line">   B_c B;</span><br><span class="line">   B=new();</span><br><span class="line">   B.randomize();</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
<ol>
<li>在上文中，A声明为rand, 这样，在C_c中，对B进行随机化，A也会随机化。如果A没有被声明为rand, 则，在C_c中，对B进行随机化，A不会随机。</li>
<li>在上文中，虽然B没有声明为rand, 但是它仍然可以调用randomize()。</li>
</ol>
</li>
<li><p>在post_randomize()中，一方面可以对前面randomize的结果根据plusargs进行覆盖，另一方面，也可以根据randomize的结果去设置一些值。</p>
</li>
</ol>
<h4 id="scoreboard-注意事项"><a href="#scoreboard-注意事项" class="headerlink" title="scoreboard 注意事项"></a>scoreboard 注意事项</h4><ol>
<li>scoreboard需要从monitor处通过TLM port 接受数据，无论是driver的驱动端还是数据接收端。在driver端，不直接从driver获取数据的原因是为了<br>防止driver驱动数据出错。</li>
<li>sb 或者其他一些component 的 assertion应该做成可选择的(可以根据config选择create sb or not), 原因有三： <ol>
<li>有些时候，数据不可&#x2F;不想预测，比如一些register tests. </li>
<li>在新的project 中 bring up TB时，需要一点一点enable, 不希望一开始报太多错。</li>
<li>high level 的TB中， 可能并不想&#x2F;不需要再用低级模块中的sb&#x2F;checker, 可能只使用high-level 的checker就好。</li>
</ol>
</li>
</ol>
<h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><ol>
<li>Testbench中所有的class 都应该放在package中。</li>
<li>interface不能放。</li>
<li>最好不要将package import 到当前的testbench 中， 而是通过scope operator 调用其中的参数&#x2F;函数。eg: A_pkg::B_c B;</li>
</ol>
<h4 id="vkit"><a href="#vkit" class="headerlink" title="vkit"></a>vkit</h4><p>vkit: modules, interface and teh packages are put together, they are collectively known as a verification kit. &#x3D;&gt; vkit.</p>
<h4 id="functional-coverage"><a href="#functional-coverage" class="headerlink" title="functional coverage"></a>functional coverage</h4><ol>
<li>几种不同的functional coverage: <ol>
<li>sb coverage</li>
<li>reg coverage (自带的)</li>
<li>monitor 检测到的traffic 的 coverage （interface中cover的是signal level的，而monitor中，我们可以把数据进一步处理一下， 成为transaction&#x2F;protocol level，然后进行覆盖分析)</li>
<li>interface seq coverage. 在interface 中的cover property, 检测有没有back to back transaction? 两个transaction之间有没有特定的delay? 其和上面monitor的区别是，monitor处理后的数据无法提供timing相关的信息。<ol>
<li>同时interface分为两种，一种是整个DUT的 input&#x2F;output, 这就是前面所说的内容。</li>
<li>第二种是单独加一个interface去检测internal signal. 去检测一些特定的FSM state, 或者其他的状态有没有达到。</li>
</ol>
</li>
<li>cfg coverage (他的对应covergroup 可以直接放在cfg class中，然后sample()放在randomize()中， 这样在每次test开始时，cfg 随机化的时候，收集一次覆盖率。这样就不用每个clk都收集，提高速度)</li>
</ol>
</li>
<li>covergroup &amp; coverpoint的几个注意事项<ol>
<li>必须要使用new去create covergroup. </li>
<li>covergroup 不是 OOP-Friendly. covergroup 不能appended or modified. 你可以在派生class中，通过写一个完全一样名字的covergroup 去overwrite,但是没有covergroup extend …之类的结构。</li>
<li>covergroup 没法debug </li>
<li>covergroup 很难re-use</li>
</ol>
</li>
<li>covergroup 应当放在一个单独的class中，将其与其他的env 分开。因为可以减少编译时间(？)</li>
<li>因此可以将其放入一个subscriber 类型的class中(传输的类型可以是seq)，收集信息，并进行覆盖分析。</li>
<li>coverage 和 checker都应该有对应的bit 可以设置去disable. </li>
<li>这里需要注意，我们不能通过检测seq来产生coverage, 原因有三：<ol>
<li>因为那是我们期望产生的seq, 可能与实际产生的不符， 因此，需要直接在interface上检测</li>
<li>在后面的project中，旧的seq可能不再被使用， 但是我们仍然需要检测这些地方有没有cover。 </li>
<li>每运行一次seq, 就要创建一次covergroup, 影响运行效率。</li>
</ol>
</li>
<li>在构建coverage group 时，有一点很重要，就是，我们需要collect coverage on what happened, instead of what we think happened. 比如，<br>不能将covergroup 放在seq中，而应该将其放在input output的interface中， 去收集数据。也可以将其放在monitor中， 在monitor处理完数据后进行收集。</li>
</ol>
<h4 id="tb-top-amp-hw-top中应该包含什么"><a href="#tb-top-amp-hw-top中应该包含什么" class="headerlink" title="tb_top &amp; hw_top中应该包含什么"></a>tb_top &amp; hw_top中应该包含什么</h4><p>tb_top: 其中可以包含各个interface的实例化，binding 和 config_db::set. 对于实例化 和 binding, 直接用下面这段就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind hw_top.A_inst </span><br><span class="line"> intA_intf intA_i(</span><br><span class="line">   .A(a), </span><br><span class="line">   .clk(clk),</span><br><span class="line">   ...</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>这个只是建议的东西。但是我感觉也可以将相应的内容放到if_bind.sv中。<br>hw_top: 包含DUT instance, 以及对应的连线。 </p>
<p>hw_top 和 tb_top分开是为了分开TB 和 DUT。我们一般不会修改DUT, 而 DV code 经常修改。</p>
<h4 id="base-env中应该放些什么？"><a href="#base-env中应该放些什么？" class="headerlink" title="base env中应该放些什么？"></a>base env中应该放些什么？</h4><ol>
<li>子env,agent, 以及child env的 ral model. </li>
<li>各类virtual interface </li>
<li>在构建环境的时候，应该考虑一下在更大的环境中使用的情况。比方说，A 下面包含B,C, D…， 那么在构建B的env时，不应该只考虑在B的验证环境中的使用，<br>还应该考虑在A中验证的情况。一般使用&#96;ifdef, 来区分。</li>
</ol>
<h4 id="cfg-class-简介"><a href="#cfg-class-简介" class="headerlink" title="cfg class 简介"></a>cfg class 简介</h4><ol>
<li>作用： 其可以被随机化，进而决定DUT 如何config, 如何产生激励，以及如何构建TB。 </li>
<li>每一env都应该有自己的cfg class, </li>
<li>cfg class中应当包含子cfg class. 子cfg class要在子env中使用。</li>
<li>cfg class 需要 before build anything, 应该先创建highest-level cfg class, 然后随机化，and then, 根据cfg class<br>中的信息去决定整个TB应该如何被创建。</li>
<li>cfg class在create的时候应该带上get_full_name(), eg: <br><code>clk_rst_cfg = clk_rst_cfg_c::type_id::create(&#123;get_full_name(), &quot;.cclk_rst_cfg&quot;&#125;);</code><br>这样做的目的是为了好debug。 因为Cfg是object， 没有component hierarchy，所以，在有多个clk_rst_cfg 时，可能会搞混，不知道信息到底来自于哪一个cfg.<br>(在打印信息时，调用get_full_name()可以把完整信息打印出来。而component 因为在创建的时候需要提供parent 信息，所以无需get_full_name())</li>
</ol>
<h4 id="register-model-注意事项"><a href="#register-model-注意事项" class="headerlink" title="register model 注意事项"></a>register model 注意事项</h4><ol>
<li><p>write &amp; update的区别是什么？ 如果连续写入两次到同一个register中，且写入的数据相同，则update有可能不会写第二次。<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;LEARN_MORE&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
</li>
<li><p>我们不能只读或者写单个reg_field. 只能access 整个reg. </p>
</li>
<li><p>difference between volatile and non-volatile </p>
<ol>
<li>non-volatile is the one that can be described as “set-and-forget.” Once written to, this field will never change its<br>value until another write occurs.</li>
<li>volatile can be changed by the RTL at any time.</li>
</ol>
</li>
<li><p>ral_block 应该在base_test中声明并实例化</p>
</li>
<li><p>在对uvm reg进行读写之前，必须对map 进行下列两项操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ral_block_a.get_default_map().set_sequencer(m_env.seqr, ral_adapter);</span><br><span class="line">ral_block_a.get_default_map().set_auto_predict(0);</span><br></pre></td></tr></table></figure>
<p>uvm_reg_map.set_sequencer()</p>
<blockquote>
<p>virtual function void set_sequencer ( uvm_sequencer_base  sequencer,    <br>uvm_reg_adapter adapter  &#x3D;  null )<br>Set the sequencer and adapter associated with this map. This method must be called before starting any sequences based on uvm_reg_sequence.</p>
</blockquote>
</li>
<li><p>uvm_reg_predictor 在声明的时候必须声明其BUSTYPE.<br><code>class uvm_reg_predictor #(type BUSTYPE=int) extends uvm_component</code><br>而在实例化中， 也需要声明其BUSTYPE<br><code>predictor = uvm_reg_predictor#(item_c)::type_id::create(&quot;predictor&quot;, this);</code></p>
</li>
<li><p>predictor 在实例化以后需要做以下几项事情：1. assign adapter and map. 2, connect bus_in imp with the port in monitor.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predictor.adapter = adapter;</span><br><span class="line">predictor.map = ral_block.get_default_map();</span><br><span class="line">env.mst_agent.mon.item_port.connect(predictor.bus_in);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="interface-注意事项"><a href="#interface-注意事项" class="headerlink" title="interface 注意事项"></a>interface 注意事项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drv : </span><br><span class="line">(vi.b_s的初始值为0)</span><br><span class="line">@(posedge vi.clk);</span><br><span class="line">vi.b_s &lt;= 1&#x27;b1;</span><br><span class="line">mon :</span><br><span class="line">forever begin </span><br><span class="line">  @(posedge vi.clk);</span><br><span class="line">  b = vi.b_s;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码中存在一个问题：mon &amp; drv中的assignment 之间的顺序并不确定，mon中的b 既有可能是1, 也有可能是0.<br>Clocking blocks:<br>为了解决上述问题，我们可以使用clocking blocks.将其放入下文中clocking block, simulator就会知道，drive 会在所有的input 都获取到值以后再驱动b_s。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clocking drv_cb @(posedge clk);</span><br><span class="line">   output b_s;</span><br><span class="line">   input rst_n;</span><br><span class="line">endclocking</span><br></pre></td></tr></table></figure>
<p>然后在driver中调用vi.drv_cb.b_s就可以了。</p>
<p>interface 是four-state logic唯一存在的地方。seq_item 产生的是2-state bit, 然后用它来drive interface中的4-state logic。 而interface中的值一旦被monitor获取，<br>他们将会被转变成2-state bits.<br>这样，interface中应当添加assertion check, 确保X&#x2F;Z的出现符合预期. <br>这里的符合预期有两种，一种是，普通的signal,我们不希望他在initial 以后出现X, 直接加一个X check 就可以了。 第二种是，和valid 一块的signal, 对<br>他的要求是，在initial 之后，当valid 为1 时， 不为X，这时加一个valid X check. </p>
<p>Notes: </p>
<ol>
<li>一定要在driver&amp;monitor中使用clocking blocks, 这样会解决所有的race conditions, 并且会让我们的transactor 像real hardware一样。</li>
<li>不要在TB中使用four-state logic. </li>
<li>在interface中添加assertion 检测4-state的正确性 (‘x or ‘z)。</li>
<li>seq_item 仍然可以通过一些参数，告诉driver去发送X 而非真正的data.</li>
</ol>
<h2 id="验证经验"><a href="#验证经验" class="headerlink" title="验证经验"></a>验证经验</h2><ol>
<li><p>对于一些counter, 不应该按照design的位宽去定义其位宽，如果定义成一样的位宽，就有可能 miss overflow issue</p>
</li>
<li><p>signal-level errors are trapped by assertions in the interface; protocol errors are spotted by monitors; and<br>transaction-level bugs are found by scoreboards.</p>
</li>
<li><p>绝大多数的test都应该是random tests. </p>
</li>
<li><p>在testbench中， 应该有一个CFG class, 他的作用是确定DUT 如何configure, how to generate stimulus, and how to build the testbench.</p>
</li>
<li><p>CFG class中，应该有些knobs， 可以随机化去影响simulation.</p>
</li>
<li><p>cfg class应该在base_test中实例化，然后传递handle给env.</p>
</li>
<li><p>&#96;uvm_fileld_* will automate a lot of work for us, and we should always use them in the components we write. </p>
</li>
<li><p>在TLM中， port 是用来发起数据的传输； imp是用来接收数据的传输； export是用来将imps expose给更高等级的components.</p>
</li>
<li><p>使用TLM 而非传递handles的原因有以下几点：</p>
<ol>
<li>handles可能无法知道哪一部分unexpected modify the data. </li>
<li>使用TLM可以很清楚的看到数据从哪里传向哪里。</li>
<li>当然，以下几种情况更适合用handles:<ol>
<li>sequence have handles to the sequencer, so they can see random knobs, and react to monitored event. </li>
<li>对于cfg class, 所有的componnents 都应该通过handles 去访问同一个实例化的cfg class.</li>
</ol>
</li>
</ol>
</li>
<li><p>uvm_config_db 中的set 和 get的类型必须一致，即使是child &amp; parent class， 也不行。</p>
</li>
<li><ol>
<li>当 assigning a value to a variable with 32 bits or fewer, it’s fine if 你没有申明值的宽度 <br>For example:<br> <code>a_item.addr = &#39;h8000_0048; // works fine</code> </li>
<li>但是当给一个宽于32bits的变量赋值时， 你必须要指明值的宽度. Otherwise,<br>Verilog will truncate all bits beyond the 32nd. For example:</li>
</ol>
</li>
</ol>
<p>   <code>a_item.addr = &#39;h8_0000_0048;  // MSB truncated! Assigns addr to &#39;h48</code><br>   <code>a_item.addr = 64&#39;h8_0000_0048; // works fine! </code>               </p>
<ol start="12">
<li>我们应该在driver &amp; monitor 中使用clocking block. That will solve all of the race conditions and will make your transactors behave like real hardware. <br>eg: 这个cb 会告诉simulator, b是一个以posedge clk 对应的output，因此，当使用此cb去drive signals的话，simulator 会知道在posedge clk后再去驱动b.<br>而对于a, 它将会在posedge clk前被sample. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clocking drv_cb @(posedge clk);</span><br><span class="line">  output b;</span><br><span class="line">  input a;</span><br><span class="line">endclocking :drv_cb</span><br></pre></td></tr></table></figure></li>
<li>在config.pl或者pkg.sv中， 添加文件或者include file的顺序很重要，如果A需要用到B中的东西， 那么应该先添加B再添加A.</li>
<li>x_check 应该被放在interface中去做。任何signal-related checking 如果可以放在assertion里面，那就放在assertion中。</li>
<li>Should you call write() or update() on the B register?<br>Using the write() task instead of the update() task could be important. If back-to-back data chosen happened to be the same,<br>then the update() task might not perform the second write. However, in this case because the B field is<br> built as volatile, even an update() will perform the write. (It’s best to be safe, though).</li>
<li>如非必要，不要predict the pins value at every clk cycle. 这会耗费大量的精力。如果要比较的act&#x2F;exp的值之间有几个clk的delay, 可以<br>把数据放在fifo中， 这样就不需要考虑delay了。 </li>
<li>The Z state is used for modeling a number situations where there are multiple drivers on a single net. </li>
<li>需要注意，systemverilog 会自动截断和填充不同的位宽，因此应当注意溢出事件。同时还应当注意处理有符号和无符号算术。比如说下面这两个expression. 他们看起来一样，<br>但是都隐含着问题。expression A， let’s say X is 32bits, if X &#x3D;&#x3D; ‘hF000_0001, X*4 &#x3D;&#x3D; ‘h0000_0004, it will be equal to Y&#x3D;&#x3D; 4. The fix for this is making sure the width of the multiplication result is large enough not to truncate using : <code>(X * 34’d4) == Y</code><br>Expression B的问题就更明显了， let’s say Y &#x3D;&#x3D; ‘h3， Y&#x2F;4 &#x3D;&#x3D; ‘h0, &#x3D;&gt; it will be equal to X &#x3D;&#x3D; 0</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expression A: (X * 4) == Y</span><br><span class="line">Expression B:  X == (Y /4)</span><br></pre></td></tr></table></figure>
<ol start="19">
<li>应当注意，我们所要验证的，是我们期望design的样子, 而非design 现在的样子。因为designer 有可能把spec理解错，或者构建错了。</li>
<li>注意reg&#x2F;option&#x2F;timing的随机化。 其中, reg随机化的值，应当是我们在silicon中实际设置的值的基础上，上下浮动1&#x2F;4（除非超过spec设定的限制). </li>
<li>注意各个module的连接与交互。各个block之间的互动中往往隐含着一些十分狡猾的bug, 而这个地方恰恰又是checker最薄弱的地方。 因此，block间交互的<br>地方需要有非常强力的assertion，从而确保module之间的handshake, protocols 都有被覆盖到。 同时，也应该通过一下方式，进一步确保所有的交互都被cover：<br>与同事讨论，检查波形，检查constraints, 检查coverage report. </li>
<li>对于random tests, 写一个与之对应的coverage(比如covergroup)，确保期望的场景有被覆盖到，是必要的。因为如果constraints 比较复杂，比较多，<br>有可能我们所期望的场景是randomize无法达到的。</li>
<li>对于async event和 power gating 要特别注意。 对于async event， 应该注意以下事项：<ol>
<li>async event 的触发时间会不会影响behaivor? </li>
<li>async event 对block当前的行为有何影响？ </li>
<li>多个aync event 能否相近，或者一块发生？</li>
</ol>
</li>
<li>check 和 assertion 应该使用ungated clk。而且记得要做negative check. </li>
<li>避免使用assert(object.randomize()), 或者相似的assert中有其他的东西。因为在一些tests中，可能把某个component中所有的constraint 都给disable掉，<br>这样，assert中的object 将无法randomize.</li>
<li>应当避免hardcoded address&#x2F;bit field position. </li>
<li>即使使用了direct test，也应该加一个coverage 去确保这个case是发生的。因为，你把这个test 搬到其他project以后，这个test 可能会无法正常运行。甚至在同一个<br>project里面，如果后面有什么update, 也可能导致整个direct test 失效</li>
<li>对于一些seq, 如果我们想加coverage, 一方面可以使用cover_property, 另一方面也可以使用covergroup, 即为: coverpoint(seq) {bins covered &#x3D; {1’b1};}</li>
<li>不要force HDL signals, 这会很难去debug, 并且你不能验证到真正的hardware.</li>
<li>不要从env中驱动signal, 要在virtual interface中驱动。(我认为这样做的目的是可以利用interface中的clocking block)</li>
<li>drive &amp; monitor signals 通过 clocking blocks &amp; modports 来避免竞争。同时，clocking blocks &amp; modport也可以避免agent 对interface中的signals的不当使用。比如，将input 当成Output使用。</li>
<li>在clocking blocks 存在时，interface 中function&#x2F;task可能会出问题 (signals 定义的时候是input, 但在clocking block 中变为output, 这时候将无法在interface中驱动这些signal)，我们可以将相应的function&#x2F;task 放入driver中。</li>
</ol>
<h4 id="关于-96-define-相关的东西，可以学习一下"><a href="#关于-96-define-相关的东西，可以学习一下" class="headerlink" title="关于&#96;define 相关的东西，可以学习一下"></a>关于&#96;define 相关的东西，可以学习一下</h4><h2 id="特定语法"><a href="#特定语法" class="headerlink" title="特定语法"></a>特定语法</h2><h4 id="1-如何在bind-中使用-96-ifdef"><a href="#1-如何在bind-中使用-96-ifdef" class="headerlink" title="1. 如何在bind 中使用 &#96;ifdef"></a>1. 如何在bind 中使用 &#96;ifdef</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bind</span> mm_component oc_if oc_if_1(</span><br><span class="line">    <span class="variable">.reset_n</span>(reset_n),</span><br><span class="line">    <span class="variable">.always_on_clk</span>(<span class="meta">`<span class="keyword">ifdef</span> DD_TB</span></span><br><span class="line">                     m_clk</span><br><span class="line">                  <span class="meta">`<span class="keyword">else</span> </span></span><br><span class="line">                     n_clk</span><br><span class="line">                  <span class="meta">`<span class="keyword">endif</span>),</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="2-constraint"><a href="#2-constraint" class="headerlink" title="2. constraint"></a>2. constraint</h4><ol>
<li><p>generate an array of random numbers where a certain value is repeated fixed number of times<br>对于下面的arr, 我想constraint使其中10个elements 的值为5. 如何去做呢？ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class numberGen;</span><br><span class="line">  rand bit[7:0] arr[100];</span><br><span class="line">  int i,j;</span><br><span class="line">  function new();</span><br><span class="line">    i = 5; j = 10;</span><br><span class="line">  endfunction</span><br><span class="line">  constraint pick_ij &#123;(arr.sum(item) with (int&#x27;(item==i))) == j;&#125;</span><br><span class="line">endclass : numberGen</span><br></pre></td></tr></table></figure>
</li>
<li><p>generate non repeating values in an array of class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A;</span><br><span class="line">rand bit [3:0] value [10];</span><br><span class="line">constraint CYCLC &#123; unique &#123;value&#125;;&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3. difference between `&#x27;&#123;&#125;`and `&#123;&#125;`</span><br><span class="line"> 1. `&#123;&#125;` means concatenation. It results in a vector that consists of bits of its operands. It is used in generic verilog operations. </span><br><span class="line"> 2. `&#x27;&#123;&#125;` is a definition of a anonymous aggregate structure such as an array or struct. It is used in aggregate/pattern assignments. It also has a set of features to do pattern expression to assign to specified members of structs and arrays.</span><br><span class="line"> 3. In case of packed arrays and structs and without pattern expressions both operators behave similarly.</span><br><span class="line"> 4. 实例： </span><br></pre></td></tr></table></figure>
<p>int A3[1:3];<br>int A9[1:9];<br>A3 &#x3D; ‘{1, 2, 3}; &lt;– legal (case0)<br>A9 &#x3D; ‘{3{A3}}; &lt;– illegal (case1)<br>A9 &#x3D; {A3, 4, 5, A3, 6}; &lt;– legal (case2)<br>A9 &#x3D; ‘{9{1}}; &lt;– legal (case3)<br>A9 &#x3D; {9{1}}; &lt;– illegal (case4)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> assignment patterns require each operands to be assignment compatible with each array element, and there needs to be an operand in the pattern for each element of the array. replication of operands is allowed\</span><br><span class="line">Array concatenation requires that each operand be assignment compatible with an element of the array, or an array of elements that are assignment compatible with an element of the array. Replication is not allowed.\</span><br><span class="line">case0 is an assignment pattern of 3 operands to an array of three elements\</span><br><span class="line">case1 is illegal because Your assignment pattern only has three (repeated) operands where nine are required. And the three operands you do have are not assignment compatible: each element. needs to be an int, not an array of ints.\</span><br><span class="line">case2 is an array concatenation whose operands total 9 array elements\</span><br><span class="line">case3 is an assignment pattern of 9 replicating operands into an array of 9 elements\</span><br><span class="line">case4 is illegal because array concatenation does not allow replication.\</span><br><span class="line"> </span><br><span class="line">5. 总结： 如果有replicating operands, `&#123;(num)&#123;...&#125;&#125;`,那么必须用`&#x27;&#123;&#125;`, 而且，用`&#x27;&#123;&#125;`的时候，一定要确保前后值位数一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 程序细节</span><br><span class="line">#### 1. how to start a test? </span><br><span class="line">A test is usually started within testbench top by a task called run_test.\</span><br><span class="line">This global task should be supplied with the name of user-defined UVM test that needs to be started. If the argument to run_test is blank, it is necessary to specify the testname via command-line options to the simulator using `+UVM_TESTNAME`.</span><br><span class="line"></span><br><span class="line">#### 2. 系统的top level应该如何构建？ </span><br><span class="line">1. 在top.sv中，在一个`inital block`中`run_test();`</span><br><span class="line">2. 在base_test中，创建并初始化各个component, ral_block，并将其连接起来。</span><br><span class="line"></span><br><span class="line">#### 3. difference bewteen tb_top and hw_top</span><br><span class="line">1. tb_top has the instances, bindings and registrations of all of the testbench interfaces. </span><br><span class="line">2. hw_top: 这里会有DUT instance, 并且会有相应的wiring connections. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 学习一下vexpand， 如:AUTO_TEMPLATE， AUTOINST</span><br><span class="line"></span><br><span class="line">#### 了解并使用一下OmniGraffle 这个app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## upf &amp; xprop &amp; emul 指南</span><br><span class="line">### 1. low power verification </span><br><span class="line">实例1. retention reg &amp; non_retention reg 共同使用同一reset, 当其reset时，可以将reg的值从X 变为valid值。</span><br><span class="line">当power gate 的时候，non_retention reg的值应该变为X, 不过普通的test无法模拟，他们还是保留原来的值。因此，这一部分必须使用low power verfication</span><br><span class="line">才能进行模拟，并看出其中的问题。\</span><br><span class="line">问题就是： power gate 以后，non_retention reg中的值变为X, 因此，在使用之前应该先去reset. 但是，上面的design, retention &amp; non-retention </span><br><span class="line">reg 用的是同一个reset. 这样，retention reg中的值也会reset. 这显示是有悖于我们的需求的。因此，两者需用不同的reset 信号。\</span><br><span class="line">还有几个例子，综合起来看，low power verification 对于power gate 之类的非常重要。 </span><br><span class="line">总结： upf 去模拟design 的power方面的行为，包括： 1. isolate the values when isolation enabled. 2. retention reg的</span><br><span class="line">保存和恢复。 3. register 在power off 的时候变为X. 4. corruption based on liberty for Hard IP.</span><br><span class="line"></span><br><span class="line">### 2. XPROP </span><br><span class="line">##### 为何需要XPROP</span><br><span class="line">X状态在RTL和gate level的处理方式不同，这可能会引起问题。 因为他们不同的语法，RTL可能会过于乐观，错误的将X转为0 或者1. 而gate level 可能过于悲观，</span><br><span class="line">将X传递下去。</span><br><span class="line">实例1. </span><br></pre></td></tr></table></figure>
<p>always @(posedge clk)<br>  if (c)<br> q &lt;&#x3D; a;<br>  else<br> q &lt;&#x3D; b;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设 c=X, a=1, b=0, 那么，</span><br></pre></td></tr></table></figure>
<p>RTL:    q &#x3D; 0;<br>Gate:   q &#x3D; X;<br>Actual: q &#x3D; ? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从上述结果可以看到，此时RTL过于乐观，q的值是未知的，但却被赋值为0. 因此，RTL在此时估计的值是错误的，并最终结果会和真实情况不相匹配。</span><br><span class="line">假设c=X, a=1, b=1, 那么</span><br></pre></td></tr></table></figure>
<p>RTL:    q &#x3D; 1;<br>Gate:   q &#x3D; X;<br>Actual: q &#x3D; 1;<br>&#96;&#96;&#96;<br>从上述结果可以看出，此时Gate 过于悲观了。<br>因此，我们的解决方法就是使用XPROP tests. 它让simulator 将X同时考虑为1和0， 驱动后面的evaluation, 最后将两个结果融合。这会消减RTL和Gate level<br>之间的不同，并和real silicon的结果更加接近。</p>
</li>
</ol>
<h3 id="3-EMUL"><a href="#3-EMUL" class="headerlink" title="3. EMUL"></a>3. EMUL</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/27/%E9%AA%8C%E8%AF%81%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" data-id="cl2ijblru0001t0ux3fhw0910" data-title="验证经验总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/04/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E8%A1%8C%E5%A4%9A%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          读书笔记 -- 并行多核体系结构基础
        
      </div>
    </a>
  
  
    <a href="/2022/03/18/shell-%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">shell_基础</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/16/vim-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">vim 使用总结</a>
          </li>
        
          <li>
            <a href="/2022/04/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B6%E8%A1%8C%E5%A4%9A%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">读书笔记 -- 并行多核体系结构基础</a>
          </li>
        
          <li>
            <a href="/2022/04/27/%E9%AA%8C%E8%AF%81%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">验证经验总结</a>
          </li>
        
          <li>
            <a href="/2022/03/18/shell-%E5%9F%BA%E7%A1%80/">shell_基础</a>
          </li>
        
          <li>
            <a href="/2022/03/15/regex-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/">regex 正则表达</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>